import client
import math 
e,c = client.getQ2()
p = 129711420978537746088867309342132426785901989689874594485896371555019986573705426172788805726178509467748040679168734095884433597017604012172054368990172572715857537355524013819947862920969421702067385445122242673064958991968666138544380365520456029952414962028711806175784928131826127885820644091951344318387
q = 174066672405085972657808881778978520582809763235147358374332409966322987290745416405220414323004782906757362579157117914494927198442645581197584273451379119673753279114693557694861941678350357667191083878100828920198503774539271289263633646647364198130180304138099281532660260760636194367337370132530987351081
n = p*q
#p and q are prime numbers
#print(e)
phi_n = (p-1)*(q-1)

def egcd(a, b):
    
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y
def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m



phi_n = (p-1) * (q-1)
d = modinv(e,phi_n)
m = pow(c, d, n)
print(m)

byte_result = m.to_bytes(math.ceil(m.bit_length()/8), byteorder="big")
string_result = byte_result.decode()

client.checkQ2(string_result)